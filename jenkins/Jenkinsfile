pipeline {
    agent any
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 1, unit: 'HOURS')
    }
    
    environment {
        PYTHON_VERSION = '3'
        VENV_DIR = 'venv'
        GIT_REPO = 'https://github.com/ron1120/Devops-ci-cd-exercise.git'
    }
    
    triggers {
        githubPush()
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    sh 'echo "Checking out repository from GitHub"'
                    git branch: 'main', credentialsId: 'RonGitUser', url: 'https://github.com/ron1120/Devops-ci-cd-exercise.git'
                    env.GIT_BRANCH_NAME = sh(script: 'git rev-parse --abbrev-ref HEAD || echo "main"', returnStdout: true).trim()
                    if (env.GIT_BRANCH_NAME == 'HEAD') {
                        env.GIT_BRANCH_NAME = 'main'
                    }
                    echo "Git branch detected: ${env.GIT_BRANCH_NAME}"
                }
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    sh '''
                        echo "Setting up Python environment"

                        # Prefer using node's python3 if present (no Docker API required)
                        if command -v python3 >/dev/null 2>&1; then
                            echo "python3 available on node ‚Äî creating venv locally"
                            python${PYTHON_VERSION} -m venv ${VENV_DIR}
                            . ${VENV_DIR}/bin/activate && pip install --upgrade pip
                            . ${VENV_DIR}/bin/activate && pip install -r requirements.txt

                        # Otherwise, use Docker only if the Docker daemon is reachable
                        elif command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
                            echo "Docker daemon reachable ‚Äî using python:3.11-slim to create venv"
                            docker run --rm -v "$PWD":/workspace -w /workspace python:3.11-slim bash -c "python${PYTHON_VERSION} -m venv ${VENV_DIR} && . ${VENV_DIR}/bin/activate && pip install --upgrade pip && pip install -r requirements.txt"

                        else
                            echo "No usable Python3 on node and Docker daemon not reachable; cannot set up Python environment"
                            echo "Please configure your Jenkins agent to have Python3, or enable Docker daemon access for this container/agent."
                            exit 1
                        fi
                    '''
                }
            }
        }
        
        stage('Lint Code') {
            steps {
                script {
                    sh '''
                        mkdir -p reports

                        if command -v python3 >/dev/null 2>&1; then
                            echo "Running linters using node's python3/venv"
                            . ${VENV_DIR}/bin/activate && flake8 app/ --output-file=reports/flake8.txt || true
                            . ${VENV_DIR}/bin/activate && pylint app/ --output=reports/pylint.txt || true

                        elif command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
                            echo "Docker daemon reachable ‚Äî running linters in python:3.11-slim container"
                            docker run --rm -v "$PWD":/workspace -w /workspace python:3.11-slim bash -c "pip install --no-cache-dir -r requirements.txt && flake8 app/ --output-file=reports/flake8.txt || true; pylint app/ --output=reports/pylint.txt || true"

                        else
                            echo "No usable Python3 on node and Docker daemon not reachable; cannot run linters"
                            exit 1
                        fi
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'reports/*.txt', allowEmptyArchive: true
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                script {
                    sh '''
                        mkdir -p reports htmlcov

                        if command -v python3 >/dev/null 2>&1; then
                            echo "Running unit tests using node's python3/venv"
                            . ${VENV_DIR}/bin/activate && pytest tests/unit/ -v --cov=app --cov-report=html:htmlcov --cov-report=xml:reports/coverage.xml --cov-report=term-missing --junit-xml=reports/unit-tests.xml

                        elif command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
                            echo "Docker daemon reachable ‚Äî running unit tests in python container"
                            docker run --rm -v "$PWD":/workspace -w /workspace python:3.11-slim bash -c "pip install --no-cache-dir -r requirements.txt && pytest tests/unit/ -v --cov=app --cov-report=html:htmlcov --cov-report=xml:reports/coverage.xml --cov-report=term-missing --junit-xml=reports/unit-tests.xml"

                        else
                            echo "No usable Python3 on node and Docker daemon not reachable; cannot run unit tests"
                            exit 1
                        fi
                    '''
                }
            }
            post {
                always {
                    junit 'reports/unit-tests.xml'
                    archiveArtifacts artifacts: 'htmlcov/**/*,reports/unit-tests.xml,reports/coverage.xml', allowEmptyArchive: false
                }
            }
        }
        
        stage('Integration Tests') {
            steps {
                script {
                    sh '''
                        mkdir -p reports

                        if command -v python3 >/dev/null 2>&1; then
                            echo "Running integration tests using node's python3/venv"
                            . ${VENV_DIR}/bin/activate && pytest tests/integration/ -v --junit-xml=reports/integration-tests.xml || true

                        elif command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
                            echo "Docker daemon reachable ‚Äî running integration tests in python container"
                            docker run --rm -v "$PWD":/workspace -w /workspace python:3.11-slim bash -c "pip install --no-cache-dir -r requirements.txt && pytest tests/integration/ -v --junit-xml=reports/integration-tests.xml || true"

                        else
                            echo "No usable Python3 on node and Docker daemon not reachable; cannot run integration tests"
                            exit 1
                        fi
                    '''
                }
            }
            post {
                always {
                    junit 'reports/integration-tests.xml'
                    archiveArtifacts artifacts: 'reports/integration-tests.xml', allowEmptyArchive: true
                }
            }
        }
        
        stage('End-to-End Tests') {
            steps {
                script {
                    sh '''
                        mkdir -p reports

                        if command -v python3 >/dev/null 2>&1; then
                            echo "Running end-to-end tests using node's python3/venv"
                            . ${VENV_DIR}/bin/activate && pytest tests/e2e/ -v --junit-xml=reports/e2e-tests.xml || true

                        elif command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
                            echo "Docker daemon reachable ‚Äî running end-to-end tests in python container"
                            docker run --rm -v "$PWD":/workspace -w /workspace python:3.11-slim bash -c "pip install --no-cache-dir -r requirements.txt && pytest tests/e2e/ -v --junit-xml=reports/e2e-tests.xml || true"

                        else
                            echo "No usable Python3 on node and Docker daemon not reachable; cannot run end-to-end tests"
                            exit 1
                        fi
                    '''
                }
            }
            post {
                always {
                    junit 'reports/e2e-tests.xml'
                    archiveArtifacts artifacts: 'reports/e2e-tests.xml', allowEmptyArchive: true
                }
            }
        }
        
        stage('Performance Tests') {
            when {
                expression {
                    boolean isProduction = env.GIT_BRANCH_NAME == 'production'
                    echo "Performance tests - branch: ${env.GIT_BRANCH_NAME}, isProduction=${isProduction}"
                    return isProduction
                }
            }
            steps {
                script {
                    sh '''
                        mkdir -p reports

                        if command -v python3 >/dev/null 2>&1; then
                            echo "Running performance tests using node's python3/venv"
                            . ${VENV_DIR}/bin/activate
                            python main.py &
                            APP_PID=$!
                            sleep 5
                            locust -f tests/performance/locustfile.py --headless --users 10 --spawn-rate 2 --run-time 30s --host http://localhost:5000 --html reports/performance-report.html || true
                            kill $APP_PID || true

                        elif command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
                            echo "Docker daemon reachable ‚Äî running performance tests in python container"
                            docker run --rm -v "$PWD":/workspace -w /workspace python:3.11-slim bash -c "pip install --no-cache-dir -r requirements.txt && python main.py & APP_PID=$!; sleep 5; locust -f tests/performance/locustfile.py --headless --users 10 --spawn-rate 2 --run-time 30s --host http://localhost:5000 --html reports/performance-report.html || true; kill $APP_PID || true"

                        else
                            echo "No usable Python3 on node and Docker daemon not reachable; cannot run performance tests"
                            exit 1
                        fi
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'reports/performance-report.html', allowEmptyArchive: true
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                script {
                    sh '''
                        mkdir -p reports

                        if command -v python3 >/dev/null 2>&1; then
                            echo "Running bandit using node's python3/venv"
                            . ${VENV_DIR}/bin/activate && bandit -r app/ -f json -o reports/bandit-report.json || true

                        elif command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
                            echo "Docker daemon reachable ‚Äî running bandit in python container"
                            docker run --rm -v "$PWD":/workspace -w /workspace python:3.11-slim bash -c "pip install --no-cache-dir -r requirements.txt && bandit -r app/ -f json -o reports/bandit-report.json || true"

                        else
                            echo "No usable Python3 on node and Docker daemon not reachable; cannot run security scan"
                            exit 1
                        fi
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'reports/bandit-report.json', allowEmptyArchive: true
                }
            }
        }
        
        stage('Create Version Tag') {
            when {
                expression {
                    boolean isMainOrDevelop = env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'develop'
                    echo "Version tag - branch: ${env.GIT_BRANCH_NAME}, isMainOrDevelop=${isMainOrDevelop}"
                    return isMainOrDevelop
                }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'RonGitUser', passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                        sh '''
                            git config user.email "jenkins@example.com"
                            git config user.name "Jenkins CI"
                            VERSION=$(date +%Y.%m.%d.%H%M%S)
                            git tag -a v$VERSION -m "Release version $VERSION" || true
                            echo "VERSION=$VERSION" > version.txt
                            echo "‚úì Version tag created locally: v$VERSION"
                            echo "Note: Git push requires SSH keys or PAT configuration in Jenkins"
                        '''
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'version.txt', allowEmptyArchive: true
                }
            }
        }
        
        stage('Build Docker Image') {
            when {
                expression {
                    boolean isMainOrDevelop = env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'develop'
                    echo "Docker build - branch: ${env.GIT_BRANCH_NAME}, isMainOrDevelop=${isMainOrDevelop}"
                    return isMainOrDevelop
                }
            }
            steps {
                script {
                    sh '''
                        # Check if Docker CLI is available
                        if ! command -v docker >/dev/null 2>&1; then
                            echo "‚ö† Docker CLI not available - skipping build"
                            exit 0
                        fi
                        
                        # Check Docker daemon availability
                        if ! docker info >/dev/null 2>&1; then
                            echo "‚ö† Docker daemon not reachable - skipping build"
                            exit 0
                        fi
                        
                        if [ -f version.txt ]; then
                            VERSION=$(cat version.txt | cut -d= -f2)
                        else
                            VERSION=${BUILD_NUMBER}
                        fi
                        
                        echo "Building Docker image: devops-testing-app:${VERSION} (linux/amd64)"
                        docker buildx create --use --name multiarch >/dev/null 2>&1 || true
                        docker buildx build --platform linux/amd64 -t devops-testing-app:${VERSION} -f docker/Dockerfile --load .
                        docker tag devops-testing-app:${VERSION} devops-testing-app:latest
                        echo "‚úì Docker image built successfully: devops-testing-app:${VERSION}"
                    '''
                }
            }
        }

        stage('Push Docker Image') {
            when {
                expression {
                    boolean isMainOrDevelop = env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'develop'
                    echo "Docker push - branch: ${env.GIT_BRANCH_NAME}, isMainOrDevelop=${isMainOrDevelop}"
                    return isMainOrDevelop
                }
            }
            steps {
                script {
                    sh '''
                        # Check if Docker CLI is available
                        if ! command -v docker >/dev/null 2>&1; then
                            echo "‚ö† Docker CLI not available - skipping push"
                            exit 0
                        fi
                        
                        # Check Docker daemon availability
                        if ! docker info >/dev/null 2>&1; then
                            echo "‚ö† Docker daemon not reachable - skipping push"
                            exit 0
                        fi
                        
                        # Determine version: try git tag, then version.txt, then BUILD_NUMBER
                        VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || cat version.txt 2>/dev/null | cut -d= -f2 || echo "${BUILD_NUMBER}")
                        
                        if [ -z "$VERSION" ] || [ "$VERSION" = "${BUILD_NUMBER}" ] && ! [ -f version.txt ]; then
                            VERSION=${BUILD_NUMBER}
                        fi

                        echo "Preparing to push devops-testing-app:${VERSION} to Docker Hub"
                    '''

                    // Use Docker Hub credentials stored in Jenkins (username/password)
                    withCredentials([usernamePassword(credentialsId: 'RonDockerUser', usernameVariable: 'DOCKERHUB_USER', passwordVariable: 'DOCKERHUB_PASS')]) {
                        sh '''
                            # Re-determine VERSION for this shell context
                            VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || cat version.txt 2>/dev/null | cut -d= -f2 || echo "${BUILD_NUMBER}")
                            if [ -z "$VERSION" ]; then
                                VERSION=${BUILD_NUMBER}
                            fi
                            
                            echo "Using VERSION=${VERSION}"
                            
                            echo "$DOCKERHUB_PASS" | docker login -u "$DOCKERHUB_USER" --password-stdin

                            # Try to inspect and push; if socket error, provide diagnostic info
                            if docker image inspect devops-testing-app:${VERSION} >/dev/null 2>&1; then
                                docker tag devops-testing-app:${VERSION} ${DOCKERHUB_USER}/devops-testing-app:${VERSION}
                                docker tag devops-testing-app:${VERSION} ${DOCKERHUB_USER}/devops-testing-app:latest
                                docker push ${DOCKERHUB_USER}/devops-testing-app:${VERSION}
                                docker push ${DOCKERHUB_USER}/devops-testing-app:latest
                                echo "‚úì Pushed images to Docker Hub: ${DOCKERHUB_USER}/devops-testing-app:${VERSION} and :latest"
                            else
                                INSPECT_ERROR=$?
                                echo "‚ö† Could not inspect image devops-testing-app:${VERSION} (error code: $INSPECT_ERROR)"
                                
                                # Try to list images to diagnose socket vs. missing image issue
                                echo "Checking available images:"
                                if docker images devops-testing-app 2>&1; then
                                    echo "No local devops-testing-app images found - build stage likely failed or was skipped"
                                    echo "This may occur if Docker socket is not accessible to Jenkins"
                                else
                                    echo "‚ö† Cannot list Docker images - socket permission issue detected"
                                    echo "Solution: Restart Jenkins container with: docker run -v /var/run/docker.sock:/var/run/docker.sock --group-add \$(stat -c '%g' /var/run/docker.sock) ..."
                                fi
                                
                                echo "Skipping push - no local image to push"
                                exit 0
                            fi

                            docker logout || true
                        '''
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                expression {
                    boolean isDevelop = env.GIT_BRANCH_NAME == 'develop' || env.GIT_BRANCH_NAME == 'main'
                    echo "Deploy - branch: ${env.GIT_BRANCH_NAME}, isDevelop/main=${isDevelop}"
                    return isDevelop
                }
            }
            stages {
                stage('Terraform Init & Plan') {
                    steps {
                        script {
                            withCredentials([
                                [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']
                            ]) {
                                sh '''
                                    echo "========================================="
                                    echo "  Terraform Init & Plan"
                                    echo "========================================="
                                    export AWS_DEFAULT_REGION="us-east-2"

                                    cd infrastructure/terraform

                                    # Determine Docker image tag
                                    if [ -f ../../version.txt ]; then
                                        VERSION=$(cat ../../version.txt | cut -d= -f2)
                                    else
                                        VERSION="${BUILD_NUMBER}"
                                    fi
                                    DOCKER_IMAGE="ronsss/devops-testing-app:${VERSION}"

                                    echo "Docker image for deployment: ${DOCKER_IMAGE}"

                                    terraform init -input=false

                                    terraform plan \
                                        -var="docker_image=${DOCKER_IMAGE}" \
                                        -out=tfplan \
                                        -input=false

                                    echo "‚úÖ Terraform plan created successfully"
                                '''
                            }
                        }
                    }
                }

                stage('Terraform Apply') {
                    steps {
                        script {
                            withCredentials([
                                [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']
                            ]) {
                                sh '''
                                    echo "========================================="
                                    echo "  Terraform Apply"
                                    echo "========================================="
                                    export AWS_DEFAULT_REGION="us-east-2"

                                    cd infrastructure/terraform

                                    terraform apply -auto-approve -input=false tfplan

                                    echo ""
                                    echo "--- Terraform Outputs ---"
                                    terraform output -json > ../../terraform_outputs.json
                                    terraform output
                                    echo ""
                                    echo "‚úÖ Infrastructure provisioned successfully"
                                '''
                            }
                        }
                    }
                }

                stage('Ansible Deploy') {
                    steps {
                        script {
                            withCredentials([
                                [$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'],
                                sshUserPrivateKey(credentialsId: 'StagingSSHKey', keyFileVariable: 'SSH_KEY_FILE'),
                                usernamePassword(credentialsId: 'RonDockerUser', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')
                            ]) {
                                sh '''
                                    echo "========================================="
                                    echo "  Ansible Deploy"
                                    echo "========================================="

                                    # Determine Docker image tag
                                    if [ -f version.txt ]; then
                                        VERSION=$(cat version.txt | cut -d= -f2)
                                    else
                                        VERSION="${BUILD_NUMBER}"
                                    fi
                                    DOCKER_IMAGE="ronsss/devops-testing-app:${VERSION}"

                                    # Get staging IP from Terraform output
                                    STAGING_IP=$(cat terraform_outputs.json | python3 -c "import sys,json; print(json.load(sys.stdin)['instance_public_ip']['value'])")
                                    echo "Staging server IP: ${STAGING_IP}"

                                    # Generate dynamic inventory
                                    cat > infrastructure/ansible/inventory.ini <<INVENTORY_EOF
[staging]
${STAGING_IP} ansible_user=ec2-user ansible_ssh_private_key_file=${SSH_KEY_FILE}
INVENTORY_EOF

                                    echo "Waiting for SSH to become available on ${STAGING_IP}..."
                                    for i in $(seq 1 30); do
                                        if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i "${SSH_KEY_FILE}" ec2-user@${STAGING_IP} "echo ready" >/dev/null 2>&1; then
                                            echo "SSH is ready!"
                                            break
                                        fi
                                        echo "  Attempt $i/30 - waiting 10s..."
                                        sleep 10
                                    done

                                    # Activate Ansible venv (pre-installed in Jenkins image)
                                    if [ -d /opt/venv ]; then
                                        . /opt/venv/bin/activate
                                    fi

                                    # Run Ansible playbook
                                    ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook \
                                        -i infrastructure/ansible/inventory.ini \
                                        infrastructure/ansible/deploy.yml \
                                        -e "docker_image=${DOCKER_IMAGE}" \
                                        -e "app_port=5000" \
                                        -e "docker_hub_user=${DOCKER_USER}" \
                                        -e "docker_hub_pass=${DOCKER_PASS}" \
                                        -v

                                    echo ""
                                    echo "‚úÖ Application deployed successfully!"
                                    echo "üåê App URL: http://${STAGING_IP}:5000"
                                '''
                            }
                        }
                    }
                }

                stage('Smoke Test') {
                    steps {
                        script {
                            sh '''
                                echo "========================================="
                                echo "  Smoke Test"
                                echo "========================================="

                                STAGING_IP=$(cat terraform_outputs.json | python3 -c "import sys,json; print(json.load(sys.stdin)['instance_public_ip']['value'])")

                                echo "Running smoke tests against http://${STAGING_IP}:5000"

                                # Health check
                                echo "1. Health check..."
                                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "http://${STAGING_IP}:5000/health")
                                if [ "$HTTP_STATUS" = "200" ]; then
                                    echo "   ‚úÖ Health check passed (HTTP ${HTTP_STATUS})"
                                else
                                    echo "   ‚ùå Health check failed (HTTP ${HTTP_STATUS})"
                                    exit 1
                                fi

                                # Homepage check
                                echo "2. Homepage check..."
                                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "http://${STAGING_IP}:5000/")
                                if [ "$HTTP_STATUS" = "200" ]; then
                                    echo "   ‚úÖ Homepage accessible (HTTP ${HTTP_STATUS})"
                                else
                                    echo "   ‚ö† Homepage returned HTTP ${HTTP_STATUS}"
                                fi

                                echo ""
                                echo "‚úÖ All smoke tests passed!"
                                echo "üåê Staging URL: http://${STAGING_IP}:5000"
                            '''
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            script {
                sh 'echo "Pipeline completed successfully!"'
                emailext (
                    subject: "‚úÖ Pipeline Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: """
                        <p>The pipeline completed successfully!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                            <li><strong>Reports:</strong> Check the artifacts section</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL}"
                )
            }
        }
        failure {
            script {
                sh 'echo "Pipeline failed!"'
                emailext (
                    subject: "‚ùå Pipeline Failure: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: """
                        <p>The pipeline failed!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                            <li><strong>Failed Stage:</strong> ${currentBuild.currentResult}</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL}"
                )
            }
        }
    }
}